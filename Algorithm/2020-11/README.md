2020-11 ALGORITHM DIARY

### 11/05 [백준 1753 최단 거리](https://www.acmicpc.net/problem/1753)

방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.
- [BJ1753.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ1753.cpp)

    다익스트라 문제를 오랜만에 풀어서,, 답을 참고해서 풀었다 ㅠㅠ 2차원 배열을 사용할 수 없어서 프라이어티 큐를 사용했다

### 11/07 [백준 1476 날짜 계산](https://www.acmicpc.net/problem/1476)

방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.
- [BJ1476.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ1476.cpp)

    세 수의 나머지가 입력값과 일치하는 수를 구해야 한다. cin cout에 익숙해지는 연습을 해야겠다.
    
### 11/08 [백준 10867 중복 빼고 정렬하기](https://www.acmicpc.net/problem/10876)

N개의 정수가 주어진다. 이때, N개의 정수를 오름차순으로 정렬하는 프로그램을 작성하시오. 같은 정수는 한 번만 출력한다.
- [BJ10867.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ10867.cpp)

    내가 왜 코딩테스트 볼때 테스트케이스 맞춰도 통과를 못하는지 알겠다!!!! 문제좀 제대로 읽자! 양수 음수 구분, 절대값 구분 하기!
    
    
### 11/08 [백준 2667 단지번호붙이기](https://www.acmicpc.net/problem/2667)

<그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.

- [BJ2667.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ2667.cpp)

    BFS로 풀었다, 내일 코딩테스트를 위해 몸풀기
    
    
### 11/14 [백준 10866 덱](https://www.acmicpc.net/problem/10866)

정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.

명령은 총 여덟 가지이다.

push_front X: 정수 X를 덱의 앞에 넣는다.
push_back X: 정수 X를 덱의 뒤에 넣는다.
pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.
pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.
size: 덱에 들어있는 정수의 개수를 출력한다.
empty: 덱이 비어있으면 1을, 아니면 0을 출력한다.
front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.
back: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

- [BJ10866.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ10866.cpp)

    자료 구조 문제가 풀고싶어져서 풀었다! solved.ac의 silver 단계의 문제를 풀어야겠다.
    
### 11/15 [백준 2302 극장 좌석](https://www.acmicpc.net/problem/2302)

어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.

그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.

오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.

예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 <123456789>는 물론 가능한 배치이다. 또한 <213465789> 와 <132465798> 도 가능한 배치이다. 그러나 <312456789> 와 <123546789> 는 허용되지 않는 배치 방법이다.

- [BJ2302.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ2302.cpp)

    실버 레벨의 Dynamic Programming 문제를 풀었다. 1번 좌석부터 시작하여, 현재 좌석과 바로 앞좌석 둘 다 vip가 아니여서 교환이 가능한경우에 -> 자리 교환을 하지 않는 경우 : 바로 앞좌석(dp[n-1])의 경우의 수와 같음 + 자리 교환을 하는 경우 : 바로 앞좌석과 앞앞좌석이 자리 교환을 하지 않는 경우에 가능하므로 바로 앞앞좌석(dp[n-2])의 경우의 수와 같음 으로 공식을 세웠다.
    
### 11/15 [백준 1292 쉽게 푸는 문제](https://www.acmicpc.net/problem/1292)

동호는 내년에 초등학교를 입학한다. 그래서 동호 어머니는 수학 선행 학습을 위해 쉽게 푸는 문제를 동호에게 주었다.

이 문제는 다음과 같다. 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고 어느 일정한 구간을 주면 그 구간의 합을 구하는 것이다.

하지만 동호는 현재 더 어려운 문제를 푸느라 바쁘기에 우리가 동호를 도와주자

- [BJ1292.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ1292.cpp)

    또 실버 레벨의 문제를 풀었다. 숫자의 시작값을 배열에 저장해두고 반복문으로 더해가면서 풀었다.
    
### 11/15 [백준 2644 촌수계산](https://www.acmicpc.net/problem/2644)

우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.

여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.

- [BJ2644.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ2644.cpp)

    실버2난이도 문제, 그래프의 최단거리를 구하듯이 풀었다! 인접 관계를 나타내는 벡터 배열과, BFS 큐, 방문했는지 확인했는 체크 배열을 사용하였다.

### 11/15 [백준 7576 토마토](https://www.acmicpc.net/problem/7576)

철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 
창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

- [BJ7576.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ7576.cpp)

    실버1난이도 문제, BFS를 이용해서 풀었다
    
### 11/16 [백준 1717 집합의 표현](https://www.acmicpc.net/problem/1717)

초기에 {0}, {1}, {2}, ... {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.

집합을 표현하는 프로그램을 작성하시오.

- [BJ1717.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ1717.cpp)
    골드4난이도 문제, divide&conquer의 대표 문제였던 것 같다. 옛날에 풀이를 본 기억이 있는데 그대로는 아니고 되살려서 풀어보았다. 집합의 root ( 가장 작은 값 ) 을 가리키는 group 배열을 선언하고, 초기에는 자기 자신만을 포함하는 집합을 이루고 있으므로 인덱스값으로 초기화한다. 합집합 연산을 할때마다 group 배열을 업데이트하고, 확인하는 연산을 하면 서로의 root 값이 같은지 확인한다. 그리고 새로 알게된점은!! cout에 endl이 오래 걸린다고 하여 #define endl '\n'을 추가해주니 시간 초과가 사라졌다.

### 11/17 [백준 11054 가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)

수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

- [BJ11054.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ11054.cpp)
    골드3난이도 문제, 가장 긴 증가하는 부분 수열 문제와 가장 긴 감소하는 부분 수열 문제를 푼 적이 있는데 이 두가지를 조합해서 dynamic programming으로 풀었다. 앞에서 부터 가장 긴 증가하는 부분수열 길이를 증가하고 뒤에서부터 가장 긴 감소하는 부분수열 길이를 저장해서 둘의 합이 max인 것을 출력하였다.

### 11/17 [백준 1644 소수의 연속합](https://www.acmicpc.net/problem/1644)

하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.

3 : 3 (한 가지)
41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)
53 : 5+7+11+13+17 = 53 (두 가지)
하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.

자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.

- [BJ1644.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ1644.cpp)
    골드3난이도 문제, prime 배열에 소수인지 체크 하고 시작을 했다. 시작 포인터와 끝 포인터를 옮겨 가며 연속된 숫자들의 합으로 N을 만들 수 있는지 확인한다.
    

### 11/18 [백준 5052 전화번호 목록](https://www.acmicpc.net/problem/5052)
전화번호 목록이 주어진다. 이때, 이 목록이 일관성이 있는지 없는지를 구하는 프로그램을 작성하시오.

전화번호 목록이 일관성을 유지하려면, 한 번호가 다른 번호의 접두어인 경우가 없어야 한다.

예를 들어, 전화번호 목록이 아래와 같은 경우를 생각해보자

긴급전화: 911
상근: 97 625 999
선영: 91 12 54 26
이 경우에 선영이에게 전화를 걸 수 있는 방법이 없다. 전화기를 들고 선영이 번호의 처음 세 자리를 누르는 순간 바로 긴급전화가 걸리기 때문이다. 따라서, 이 목록은 일관성이 없는 목록이다. 

- [BJ5052.cpp](https://github.com/Seulwoo/DailyStudy/blob/main/Algorithm/2020-11/BJ5052.cpp)
    골드4난이도 문제, 나는 그냥 정렬 후 서브 스트링을 비교해서 풀었는데 정석 풀이는 Trie를 이용하는 것 같다. 다시 공부를 해야겠다.
